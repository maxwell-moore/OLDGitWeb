<Max-WelcomePage></Max-WelcomePage>
<h2>My Life as an Engineer</h2>
<p>
    I'd like to first say that I don't yet have my P.Eng, and that I am not an engineer, having said that I do have a B.Eng, and from here 
    on I will treat them as essentially interchangable. 
    Engineering has been an interesting journey for me. Parts of it I loved and parts of it I hate. I have learned concepts that will never leave me, 
    but I have done much more than that. I have changed my perception of problems and tasks entirely. If you read my math page maybe you already 
    have an idea of the excitment I felt when I realized a 2 or 3 or 4 line intersection problem, was actually just a n-line intersection problem.
    'n-line' sounds very comfortable to me now, or an 'n-piece' problem. Something that runs in O(n) time - (this is pronounced as O of n). 
</p>

<h3>The letter 'n' and How it changed my life</h3>
<p>
One of the main tenants of engineering is making a product that works. Not one that you <em>think</em> will work. A real living product, for 
real living people. One constant about people is that they tend to be expanding. In whichever way they want more. They want to be able to handle 
more customers. They want more money. They want more productivity. They want more coffee. Maybe that last one is just me.
This makes the concept of expandability very important for engineers. If we build something to solve a small problem we are always interested to 
see if it can solve a similar problem, only larger. If I am handed a program that estimates the trajectory of a planet around the sun over a year
- something that legitimately would have blown my highschool-mind all by itself. I think to myself "okay, but what about 2 planets? what about 
over a millenia?" Sometimes it is very do-able, sometimes the code has been built in such a modular, efficient way that I can change a variable - 
we'll call it 'n' - from 1 to 50 and suddenly I am modelling the first fifty alphabetically-ordered planets in the nasa registry. This is how 
engineering has taught me to frame my problems, in terms of reality and in terms of expandability, modularity, simplicity. <br> <br>

This is where O(n) becomes a factor, because maybe I built a beautifully modular program it does run for 50 planets and over a millenia. But, wait
its not printing anything? Maybe the program runs fast for 1 input but 50 its terribly bogged down. One might think it takes 50 times the length of 
time - and why wouldn't it? Well there are a lot of contributing factors but the end product - what I try my very hardest to look for - is what 
is referred to as the time-complexity of the solution. O(n) is simply what we call linear, in a solution like this you would see an execution time
5 times longer, for 5 times as many inputs- planets in this case. O(n<sup>2</sup>) is Quadratic, and would mean for inputs 5 times the execution time 
will see and increase of 25 times. Or looping back to our example and increase of 50 times would see 2500 times the execution time. Yikes. After seeing
these types of problems in action again and again on a variety of systems. Anything from simple Search and Sort algorithms to the Runge-Kutta
approximations I talk about in the math section. I eventually became very sensitive to the complexity of an Algorithmic solution. What is an 
Algorithm?
</p>

<h3>The word 'algorithms' and how it changed my life</h3>

<p>
    An algorithm is basically and step-by-step process. In computing this is everything. In my masters program I have studied the 
    formal formulation of Greedy algorithm by the greedy choice property and the mathematical structure of a Matroid I have studied non-convex 
    optimization algorithms. I have studied recursive algorithms. Brute force Algorithms. Randomized algorithms. Depth first, breadth first, Graph 
    based and pretty much every other alrorithm under the sun.
</p>

<p >
    Algorithms are largely in part what made me want to be a <S>Computer Scientist</S> Software Engineer. It all started in my tenth grade
    <S>Computer Science</S> Software Engineering class. Mr B. gave me a list of objects and he told me to make an algorithm to sort them. they 
    were numbers and he just wanted them in ascending order '3,4,2,5,1' to become '1,2,3,4,5'. No problem I told him. It really wasn't, in 
    just under half an hour a young-adolescent Max learned what a selection sort was and implemented it in turing (who uses turing Mr B.?). When I 
    hit a button "1,2,3,4,5" appeared. CheckMate Mr B. "Maybe not so fast." he said and linked me a csv with a couple thousand numbers. I laughed
    and hit run again, "I'll show you." ... "umm, just one second." My program hung for minutes and finally I terminated it, I was beyond confused - 
    the original implementation had run in just a second. The CSV included 1000's of numbers and with my terrible best case O(n<sup>2</sup>) (I 
    can't even make it through this paragraph without that letter coming back to bite me.) it took 1 000 000's of times longer to run. Well it turns 
    out millions of seconds can add up pretty quickly. This was the day I learned algorithms wasn't just about doing something with a pattern. They 
    were about doing something with a pattern <em>intelligently</em>. This knowledge challenged me. it drove me. This interest in solving 
    problems, quickly and effectively lead my down the path I am currently on. It made me the <S>Computer Scientist</S> Software Engineer that I 
    am today.
</p>

<h3><S>Computer Scientist</S> Software Engineer</h3>

<p>
Maybe you all have been asking yourself what the difference between Computer Science and Software Engineering is. I bet at the very least 
most of you are wondering why I have left a bunch of struck out text all through my website. If you know me you are likely asking yourself 
why I chose to be a SE and not a CS. Let me start by describing what the difference <s>is</s> should be.

</p>

<p >
Computer science should be more hypothetical and as such less applied than software engineering. A Software engineer might focus on the organizing 
a solution for a company knowinch which pieces of code should go where and why. A Computer Scientist would know more about the time complexities 
of those pieces, about the algorithms and which one is the fastest. A Software engineer might focus on modularity and expandability while a 
computer science would focus on optimisation and speed. At the '/root' it is exactly what it sounds like - a computer scientist is based more in 
the Science behind computing while an Software Engineer - like any other type of Engineer - is there to get a job done. 
<br> <br>
"Hey Max you didn't tell us why you just left a bunch of struck out text sitting around." Well mysterious unclaimed voice, you're right. The answer 
comes in two parts, firstly I leave it mentioned as a joke. Many people think that these two professions are so similar they deserve no 
distinction, which may be true. Having said that I have now worked a great deal in my masters as a self-proclaimed computer scientist and an equal 
amount if not greater as a Software Engineer, both in my undergraduate degree and in my work during and afterward. I would say, given these 
experiences that there is a great deal of difference between the two.  
<br> <br>
Secondly I leave this struck out text as a strange sign of respect. Anyone who knows me well will know that I have strange if not terrible 
expressions of respect. Having said this I do have a great deal of respect of computer scientists, a title that for the most part I won't feel 
that I have earned personally until I complete my masters, and even then maybe only partially. This is somewhat contrasted to how a lot of 
Software Engineers feel - which is that they are strictly more important/educated/capable etc than Computer Scientists. I hate this view 
almost as much as I hate people who see no value in educations in the arts, for instance. Math, unlike engineering - is an art, and its an 
art that computer scientists deal with a great deal more than Engineers. its this art that I love about CS, and this art that I strive to 
improve on in my masters. Its this specific beauty that drives me to respect CS students and workers as much or more than Software Engineers. 
I suppose its this internal struggle that I feel, the identity crisis I interact with everyday, that makes me tip my hat to Computer Scientists 
and, is why you'll see it all over a page aptly labeled just "EngPage".

</p>

<h3 style="margin-bottom: 100px;">Capstone Project. and the fun I had doing it</h3>
<h4>Initial Words</h4>
<p>
    I've done a lot of engineering projecits in my life, but this is atleast one I can point to for having learned a lot about co-operation 
    amongst other engineering skills. Ah, my capstone project. At our school a Capstone is what an engineering group does as a full year project. 
    Essentially to show what they have learned over the last 4 years.
    What can I say other than if my group-mates are reading this now, it's all in good fun. This project was 
    simultaneously one of the most frustrating and rewarding projects I have ever done in my life. it was one of my best experiences 
    with teambuilding, modularizing, structuring and working with code. 
</p>


<h4>Project Direction</h4>
<p>


</p>

<p>
    So what did we do? Well our team started with this initial thought that we would build a sort of automated strong-box, a very practical item 
    that we very well may have been able to market. Essentially it would have ended up being the most secure mailbox you could imagine, so that 
    delivery companies would never leave that annoying little "It's at the nearest post office" note.  

</p>

<p>
    We didn't do that.
</p>

<p>
    GM (general motors) works closely with out capstone groups and our second idea was to build a small-scale line-detecting car. Not only was 
    this within our capabilities as a group, it was super interesting! and Just imagine the contacts we would get at a huge company like GM! We 
    could use machine vision, our knowledge of different motors! Algorithms that would have to work almost instantly! 
</p>

<p>
    We didn't do that.
</p>

<p> Our third idea was to build an automated pool robot. Why? you ask? Well ... er - it still uses our knowledge of motors! um... 
    it will still need machine vision! I bet the decision making algorithm would be complex? ... ummm... it's really really cool?
</p>


<p>
    It was <em>really, really </em> <b>cool</b>
</p>

<h4>Project Details</h4>

<p>
    After what seems like a thousand struggles we did finally end up building a full pool playing machine. We even won the capstone competition. 
    Personally I worked on the machine vision - how would the machine know where the balls were? Another Software Engineer worked on the decision 
    logic - assuming we knew where the balls were which shot would we try to make? 2 Mechatronics Engineers worked on building the physical machine, 
    and 2 others worked on the electronics. 
</p>

<h4>Engineering Struggles and Triumps</h4>
<p>
    I wont talk here about the struggles the other teams on our project faced, but everyone had them - in fact I most likely got off light. I will, 
    however, discuss some of the engineering decisions I made here. My first problem was that I had never worked with any machine vision <b>or</b>
    with CPP, more on that later. Of course I took an approach at this where I tried to find something implementable and very early on. What I came 
    up with was some packaged used by matlab. Ah matlab. My Crutch. I spent hours researching how machine vision worked. On how some of the 
    transforms would help to find circular objects. How to find the linear edges of the table. After this I spent hours on hours implementing 
    these transforms, and fine tuning each of the transforms to find just what I needed; but it didn't find them quickly and unless I ran them 
    with extremely low tolerances (which would take minutes, if not hours) they wouldn't find the balls at all. It was time to pivot. 

</p>

<p>
    What I ended up working with was an implementation of openCV made for CPP which took hours - nearly days - to even set up the environment for,
    but I ended up taking a lot of the knowledge I already had on the transforms and it applying it here and within 10 hours of CPP coding I was 
    finding the vast majority of the balls - and really accurately, atleast ... it looked accurate, they were circled in the pictures?

</p>

<p>
    It turns out circled in pictures and accurately measured in real life are 2 very different things; how we ended up solving this problem was 
    by putting lines of red tape around the table and painstakingly measuring the exact distance between these red lines. after this we had a 
    grounding point, and from there it was just mathematics on what the actual position of the ball was. 
</p>

<h4>Conclusion</h4>

<p>

    In the end my program found balls within about half a centimetre of accuracy over 90 percent of the time, and everyone elses portions 
    worked what I would describe as more than sufficiently; they truly were an incredible group! You can watch a video below, and I'll include 
    some of the documentation we worked on in case you want (a LOT) more details!

</p>


<p style="margin-bottom: 300px;">
</p>